# =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  = 
# Returns the covariance equivalence and reduced form betas from betas which have 
# been produced by the function interactPVAR.m and afterwards evaluated with evalpvar.m.
# The function produces reduced form betas as in a simple PVAR such that all usual programs
# (in particular IRFcreator.m) can be used. 
#
# Required inputs are:
# - betaeval: The structural betas which have been evaluated for a particular value of the 
#             interaction terms (betaeval is the output of the evalpvar.m program) 
# - fPkomega: is the (co)variance matrix generated by the structural errors from the 
#             interactPVAR.m program (the off-diagonal elements are zero).
# - lag:      The number of lags used inthe estimation
#
# The ouput is given by:
# - betairf: Reduced form beta equivalents 
# - Pkomega: Pkomega equivalent that derives form choleski decomposing the covariance matrix
# - azero:   The azero matrix (lower diagonal)
#
# =============================================================================================
# See also evalpvar, IRFcreator, IPVARboot, IRF_IPVAR, interactPVAR
#
# Written by Pascal Towbin and Sebastian Weber - 20.02.2009
# edited 21.5.2009
# Translated to Python by A. Goumilevski - 05.01.2023

import numpy as np

def irfpreppvar(betaeval,fPkomega,lag):
    
    neq = np.shape(betaeval)[1]	 # number of equations
    std = np.sqrt(np.diag(fPkomega))
    
    evalbeta2 = np.vstack([np.zeros(neq),betaeval[:neq-1]])
    evalbeta2 = np.transpose(evalbeta2)
    evalbeta4 = np.zeros((neq,neq))
    
    #for i in range(neq): 
    #    evalbeta3(:,i) = evalbeta2(:,end-i+1)  #reverses collumns
    #hPkomega = eye(neq)+evalbeta3 NEW NOT NEEDED ANYMORE
    
    for i in range(neq): 
        evalbeta4[:,i] = evalbeta2[:,neq-1-i]
    azero = np.eye(neq) - evalbeta4
    
    B0 = np.zeros((neq,neq))
    for i in range(neq):        
        #Pkomega(:,i) = hPkomega(:,i).*std(i,1) #
        B0[i] = azero[i]/std[i] ####################Replaced#new!

    Pkomega = np.linalg.inv(B0) ##NEW, Inverse and reversing signs for off diagonale elements (hPkomega) is not the same!
    
    betairf  = np.zeros((neq*lag,neq))
    for lg in range(lag):
        betairf[neq*lg:neq*(1+lg)] = np.transpose((np.linalg.inv(azero) @ np.transpose(betaeval[(neq-1)+neq*lg:(neq-1)+neq*(1+lg)])))

    
    betairf = np.vstack([betairf, np.transpose(np.linalg.inv(azero) @ betaeval[-1])]) #constant # I replaced hPkomega by azero!!
    
    return betairf, Pkomega, azero

